# POD documentation - main docs before the code

=head1 NAME

FuhaoPerl5Lib::FastqKit

=head1 SYNOPSIS

Fasta -related tools

=head1 DESCRIPTION

=over 4

=item FastqCompareIds($inR1.fq[.gz], $inR2.fq[.gz], $pattern, $out_shared.list, $out_uniqueR1.list, $out_uniqueR2.list)

    * Compare fastq ids and output shared uniqueR1 and uniqueR2
    * Support gzipped Fastq input (Needs Linux: zcat)
    * Pattern Pattern:
          Pattern1: '\\@(\\S+)\\/[12]\\s*\\S*'
          Pattern2: '\\@(\\S+)\\s*\\S*'
    * Dependency: zcat
    * Return: 1=Success    0=failure

=item MergeBam2Fastq($out.fq, \%filehash)

    * Merge fastq files generated by bam2fastq into one fastq file
    * %filehash=('R1' => $file_fastqR1[.gz], 'R2' => $file_fastqR2[.gz], 'M' => $file_fastqUnpaired)
    * Note: Fastq input supports gzipped fq, needs zcat;
    * Return: 1=Success    0=failure

=item ShuffleFastq($fqR1.infile[.gz], $fqR2.infile[.gz], $fq.out[.gz])

    * Shuffle separate fastq file into one
    * Dependency: zcat gzip
    * Note: Do NOT check pairness
    * Return: 1=Success    0=failure

=item ShuffleFastq2Fasta(inR1.fq[.gz], inR2.fq[.gz], $out.fa[.gz])

    * SHUFFLE paired fastq to fasta
    * Dependency: zcat, gzip
    * Return: 1=Success    0=failure

=back

=head1 FEEDBACK

=head2 Support

Please send you questions or bug reports to Email:

I<lufuhao@gmail.com>

=head1 AUTHORS - Fu-Hao Lu

Email: lufuhao@gmail.com (Always)
       Fu-Hao.Lu@jic.ac.uk (2012-2016)

=head1 CONTRIBUTORS

None

=head1 APPENDIX

Fight against Bioinformatics with Perl ^_^

=cut

#Coding starts
package FuhaoPerl5Lib::FastqKit;
use strict;
use warnings;
use Exporter;
use Cwd;
use vars qw($VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS);
$VERSION     = '20171205';
@ISA         = qw(Exporter);
@EXPORT      = qw();
@EXPORT_OK   = qw(MergeBam2Fastq ShuffleFastq2Fasta ShuffleFastq FastqCompareIds);
%EXPORT_TAGS = ( DEFAULT => [qw(MergeBam2Fastq ShuffleFastq2Fasta ShuffleFastq FastqCompareIds)],
                 ALL    => [qw(MergeBam2Fastq ShuffleFastq2Fasta ShuffleFastq FastqCompareIds)]);

my $FastqKit_success=1;
my $FastqKit_failure=0;
my $FastqKit_debug=0;



### Merge fastq files generated by bam2fastq into one fastq file
### MergeBam2Fastq($out.fq, ('R1 => $fastqR1, 'R2' => fastqR2, 'M' => $fastqUnpaired)
### Global: $FastqKit_success=1; $FastqKit_failure=0;
### Dependency: zcat
### Note:
sub MergeBam2Fastq {
	my ($MBFoutfq, $MBFbam2fastq)=@_;
	
	local *MBFOUTFQ;
	my $MBFsubinfo='SUB(FastqKit::MergeBam2Fastq)';
	
	unless (defined $MBFoutfq) {
		print STDERR $MBFsubinfo, "Error: invalid output Fastq fiilename\n";
		return $FastqKit_failure;
	}
	unlink $MBFoutfq if (-e $MBFoutfq);
	
	close MBFOUTFQ if (defined fileno(MBFOUTFQ));
	unless (open (MBFOUTFQ, "> $MBFoutfq")) {
		print STDERR $MBFsubinfo, "Error: can not write output Fastq: $MBFoutfq\n";
		return $FastqKit_failure;
	}
	
	if (exists ${$MBFbam2fastq}{'R1'} and -s ${$MBFbam2fastq}{'R1'} and exists ${$MBFbam2fastq}{'R2'} and -s ${$MBFbam2fastq}{'R2'}) {
		close MBFQR1 if (defined fileno(MBFQR1));
		close MBFQR2 if (defined fileno(MBFQR2));
		if (${$MBFbam2fastq}{'R1'} =~/(\.fq$)|(\.fastq$)/i) {
			unless (open (MBFQR1, "< ${$MBFbam2fastq}{'R1'}")) {
				print STDERR $MBFsubinfo, "Error: can not open R1 Fastq: ${$MBFbam2fastq}{'R1'}\n";
				return $FastqKit_failure;
			}
		}
		elsif (${$MBFbam2fastq}{'R1'} =~/(\.fq\.gz$)|(\.fastq\.gz$)/i) {
			unless (open (MBFQR1, "zcat ${$MBFbam2fastq}{'R1'} | ")) {
				print STDERR $MBFsubinfo, "Error: can not open gziped R1 Fastq: ${$MBFbam2fastq}{'R1'}\n";
				return $FastqKit_failure;
			}
		}
		else {
			print STDERR $MBFsubinfo, "Error: can not guess R1 Fastq format: ${$MBFbam2fastq}{'R1'}\n";
			return $FastqKit_failure;
		}
		if (${$MBFbam2fastq}{'R2'} =~/(\.fq$)|(\.fastq$)/i) {
			unless (open (MBFQR2, "< ${$MBFbam2fastq}{'R2'}")) {
				print STDERR $MBFsubinfo, "Error: can not open R2 Fastq: ${$MBFbam2fastq}{'R2'}\n";
				return $FastqKit_failure;
			}
		}
		elsif (${$MBFbam2fastq}{'R2'} =~/(\.fq\.gz$)|(\.fastq\.gz$)/i) {
			unless (open (MBFQR2, "zcat ${$MBFbam2fastq}{'R2'} | ")) {
				print STDERR $MBFsubinfo, "Error: can not open gziped R2 Fastq: ${$MBFbam2fastq}{'R2'}\n";
				return $FastqKit_failure;
			}
		}
		else {
			print STDERR $MBFsubinfo, "Error: can not guess R2 Fastq format: ${$MBFbam2fastq}{'R2'}\n";
			return $FastqKit_failure;
		}
		while (my $MBFline=<MBFQR1>) {
			print MBFOUTFQ $MBFline;
			$MBFline=<MBFQR1>; print MBFOUTFQ $MBFline;
			$MBFline=<MBFQR1>; print MBFOUTFQ $MBFline;
			$MBFline=<MBFQR1>; print MBFOUTFQ $MBFline;
			$MBFline=<MBFQR2>; print MBFOUTFQ $MBFline;
			$MBFline=<MBFQR2>; print MBFOUTFQ $MBFline;
			$MBFline=<MBFQR2>; print MBFOUTFQ $MBFline;
			$MBFline=<MBFQR2>; print MBFOUTFQ $MBFline;
		}
		close MBFQR1;
		close MBFQR2;
	}
	
	if (exists ${$MBFbam2fastq}{'M'} and -s ${$MBFbam2fastq}{'M'}) {
		close MBFQM if (defined fileno(MBFQM));
		if (${$MBFbam2fastq}{'M'} =~/(\.fq$)|(\.fastq$)/i) {
			unless (open (MBFQM, "< ${$MBFbam2fastq}{'M'}")) {
				print STDERR $MBFsubinfo, "Error: can not open UNPAIRED Fastq: ${$MBFbam2fastq}{'M'}\n";
				return $FastqKit_failure;
			}
		}
		elsif (${$MBFbam2fastq}{'M'} =~/(\.fq\.gz$)|(\.fastq\.gz$)/i) {
			unless (open (MBFQM, "zcat ${$MBFbam2fastq}{'M'} | ")) {
				print STDERR $MBFsubinfo, "Error: can not open gziped UNPAIRED Fastq: ${$MBFbam2fastq}{'M'}\n";
				return $FastqKit_failure;
			}
		}
		else {
			print STDERR $MBFsubinfo, "Error: can not guess UNPAIRED Fastq format: ${$MBFbam2fastq}{'M'}\n";
			return $FastqKit_failure;
		}
		while (my $MBFline=<MBFQM>) {
			print MBFOUTFQ $MBFline;
			$MBFline=<MBFQM>; print MBFOUTFQ $MBFline;
			$MBFline=<MBFQM>; print MBFOUTFQ $MBFline;
			$MBFline=<MBFQM>; print MBFOUTFQ $MBFline;
		}
		close MBFQM;
	}
	
	close MBFOUTFQ;
	
	if (-s $MBFoutfq) {
		return $FastqKit_success;
	}
	else {
		return $FastqKit_failure;
	}
}



### SHUFFLE paired fastq to fasta
### ShuffleFastq2Fasta($forward_reads.fq[.gz], $reverse_reaads.fq[.gz], $outfile.fa[.gz])
### Global: $FastqKit_success=1; $FastqKit_failure=0;
### Dependency: zcat, gzip
### Note:
sub ShuffleFastq2Fasta {
	my ($SFFpe1fastq, $SFFpe2fastq, $SFFout_fasta)=@_;
	
	my $SFFsubinfo='SUB(FastqKit::ShuffleFastq2Fasta)';
	local *SFFPE1FASTQ; local *SFFPE2FASTQ; local *SFFOUTFASTA;
		
	unless (defined $SFFpe1fastq and -e $SFFpe1fastq) {
		print STDERR $SFFsubinfo, "Error: invalid R1 fastq files\n";
		return $FastqKit_failure;
	}
	unless (defined $SFFpe2fastq and -e $SFFpe2fastq) {
		print STDERR $SFFsubinfo, "Error: invalid R2 fastq files\n";
		return $FastqKit_failure;
	}
	unless (defined $SFFout_fasta and $SFFout_fasta=~/^\S+$/) {
		print STDERR $SFFsubinfo, "Warnings: undefined/invalid output fasta file name.\n";
		return $FastqKit_failure;
	}
	if (-e "$SFFout_fasta") {
		unlink "$SFFout_fasta";
		print STDERR $SFFsubinfo, "Warnings: existing output fasta file deleted.\n";
	}
	
### open R1 fastq
	close SFFPE1FASTQ if (defined fileno(SFFPE1FASTQ));
	if ($SFFpe1fastq=~/\.gz$/i) {
		print $SFFsubinfo, "Info: gzipped R1 FASTQ file detected: $SFFpe1fastq\n";
		unless (open(SFFPE1FASTQ, "zcat $SFFpe1fastq |")) {
			print $SFFsubinfo, "Error: can not open gzipped R1 FASTQ file\n";
			return $FastqKit_failure;
		}
	}
	elsif ($SFFpe1fastq=~/(\.fq$)|(\.fastq$)/i) {
		print $SFFsubinfo, "Info: flat R1 FASTQ file detected: $SFFpe1fastq\n";
		unless (open(SFFPE1FASTQ, "< $SFFpe1fastq")) {
			print $SFFsubinfo, "Error: can not open flat R1 FASTQ file\n";
			return $FastqKit_failure;
		}
	}
	else {
		print $SFFsubinfo, "Error: do NOT known how to open R1 FASTQ file: $SFFpe1fastq\n";
		return $FastqKit_failure;
	}
### open R2 fastq
	close SFFPE2FASTQ if (defined fileno(SFFPE2FASTQ));
	if ($SFFpe2fastq=~/\.gz$/i) {
		print $SFFsubinfo, "Info: gzipped R2 FASTQ file detected: $SFFpe2fastq\n";
		unless (open(SFFPE2FASTQ, "zcat $SFFpe2fastq |")) {
			print $SFFsubinfo, "Error: can not open gzipped R2 FASTQ file\n";
			return $FastqKit_failure;
		}
	}
	elsif ($SFFpe2fastq=~/(\.fq$)|(\.fastq$)/i) {
		print $SFFsubinfo, "Info: flat R2 FASTQ file detected: $SFFpe2fastq\n";
		unless (open(SFFPE2FASTQ, "< $SFFpe2fastq ")) {
			print $SFFsubinfo, "Error: can not open flat R2 FASTQ file\n";
			return $FastqKit_failure;
		}
	}
	else {
		print $SFFsubinfo, "Error: do NOT known how to open R2 FASTQ file: $SFFpe2fastq\n";
		return $FastqKit_failure;
	}
### open output fasta
	close SFFOUTFASTA if (defined fileno(SFFOUTFASTA));
	if ($SFFout_fasta=~/(\.fa$)|(\.fas$)|(\.fasta$)/i) {
		unless (open(SFFOUTFASTA, "> $SFFout_fasta")) {
			print $SFFsubinfo, "Error: can not write flat output fasta: $SFFout_fasta\n";
			return $FastqKit_failure;
		}
	}
	elsif ($SFFout_fasta=~/\.gz$/i) {
		unless (open(SFFOUTFASTA, " | gzip -9 -c > $SFFout_fasta")) {
			print $SFFsubinfo, "Error: can not write gzipped output fasta: $SFFout_fasta\n";
			return $FastqKit_failure;
		}
	}
	else {
		print $SFFsubinfo, "Error: do not known how to write output fasta: $SFFout_fasta\n";
		return $FastqKit_failure;
	}
	while (my $SFFline1=<SFFPE1FASTQ>) {
		$SFFline1=~s/\s+.*$/\/1/;### Note: readname 1:N:0. comment this line if readname/1
		$SFFline1=~s/^\@/\>/;
		print SFFOUTFASTA $SFFline1;
		$SFFline1=<SFFPE1FASTQ>; print SFFOUTFASTA $SFFline1;
		$SFFline1=<SFFPE1FASTQ>;
		$SFFline1=<SFFPE1FASTQ>;
		my $SFFline2=<SFFPE2FASTQ>;
		$SFFline2=~s/\s+.*$/\/2/;### Note: readname 2:N:0. comment this line if readname/2
		$SFFline2=~s/^\@/\>/;
		print SFFOUTFASTA $SFFline2;
		$SFFline2=<SFFPE2FASTQ>; print SFFOUTFASTA $SFFline2;
		$SFFline2=<SFFPE2FASTQ>;
		$SFFline2=<SFFPE2FASTQ>;
	}
	close SFFPE1FASTQ;
	close SFFPE2FASTQ;
	close SFFOUTFASTA;
	if (-s "$SFFout_fasta") {
		print $SFFsubinfo, "Info: fastq file successfully converted: $SFFout_fasta\n";
		return $FastqKit_success;
	}
	else {
		print STDERR $SFFsubinfo, "Error: Failed to convert fastq to fasta: $SFFout_fasta\n";
		return $FastqKit_failure;
	}
}



### Shuffle separate fastq file into one
### ShuffleFastq($fqR1.infile[.gz], $fqR2.infile[.gz], $fq.out[.gz])
### Global: 
### Dependency: zcat gzip
### Note: Do NOT check pairness
sub ShuffleFastq {
	my ($SFfastq1in, $SFfastq2in, $SFfastqout)=@_;

	my $SFsubinfo='SUB(FastqKit::ShuffleFastq)';
	local *SFFASTQ1INPUT; local *SFFASTQ2INPUT; local *SFFASTQOUTPUT;

	unless (defined $SFfastq1in and -s $SFfastq1in) {
		print STDERR $SFsubinfo, "Error: invalid Fastq R1\n";
		return $FastqKit_failure;
	}
	unless (defined $SFfastq2in and -s $SFfastq2in) {
		print STDERR $SFsubinfo, "Error: invalid Fastq R2\n";
		return $FastqKit_failure;
	}
	unless (defined $SFfastqout) {
		print STDERR $SFsubinfo, "Error: invalid Fastq output\n";
		return $FastqKit_failure;
	}
	unlink $SFfastqout if (-e $SFfastqout);
	
	close SFFASTQ1INPUT if (defined fileno(SFFASTQ1INPUT));
	if ($SFfastq1in=~/\.gz$/i) {
		unless (open SFFASTQ1INPUT, "zcat $SFfastq1in | ") {
			print STDERR $SFsubinfo, "Error: can not open gzipped fastq R1: $SFfastq1in\n";
			return $FastqKit_failure;
		}
	}
	elsif ($SFfastq1in=~/(\.fq$)|(\.fastq$)/i) {
		unless (open SFFASTQ1INPUT, " < $SFfastq1in") {
			print STDERR $SFsubinfo, "Error: can not open fastq R1: $SFfastq1in\n";
			return $FastqKit_failure;
		}
	}
	else {
		print STDERR $SFsubinfo, "Error: can not guess fastq R1 format: $SFfastq1in\n";
		return $FastqKit_failure;
	}
	close SFFASTQ2INPUT if (defined fileno(SFFASTQ2INPUT));
	if ($SFfastq2in=~/\.gz$/i) {
		unless (open SFFASTQ2INPUT, "zcat $SFfastq2in | ") {
			print STDERR $SFsubinfo, "Error: can not open gzipped fastq R2: $SFfastq2in\n";
			return $FastqKit_failure;
		}
	}
	elsif ($SFfastq2in=~/(\.fq$)|(\.fastq$)/i) {
		unless (open SFFASTQ2INPUT, " < $SFfastq2in") {
			print STDERR $SFsubinfo, "Error: can not open fastq R2: $SFfastq2in\n";
			return $FastqKit_failure;
		}
	}
	else {
		print STDERR $SFsubinfo, "Error: can not guess fastq R2 format: $SFfastq2in\n";
		return $FastqKit_failure;
	}
	close SFFASTQOUTPUT if (defined fileno(SFFASTQOUTPUT));
	if ($SFfastqout=~/\.gz$/i) {
		unless (open SFFASTQOUTPUT, " | gzip -9 > $SFfastqout") {
			print STDERR $SFsubinfo, "Error: can not write gzipped fastq R2: $SFfastqout\n";
			return $FastqKit_failure;
		}
	}
	elsif ($SFfastqout=~/(\.fq$)|(\.fastq$)/i) {
		unless (open SFFASTQOUTPUT, " > $SFfastqout") {
			print STDERR $SFsubinfo, "Error: can not write fastq R2: $SFfastqout\n";
			return $FastqKit_failure;
		}
	}
	else {
		print STDERR $SFsubinfo, "Error: can not guess output fastq format: $SFfastqout\n";
		return $FastqKit_failure;
	}

	while(my $SFline=<SFFASTQ1INPUT>) {
		print SFFASTQOUTPUT $SFline;
		$SFline = <SFFASTQ1INPUT>;
		print SFFASTQOUTPUT $SFline; 
		$SFline = <SFFASTQ1INPUT>;
		print SFFASTQOUTPUT $SFline; 
		$SFline = <SFFASTQ1INPUT>;
		print SFFASTQOUTPUT $SFline; 

		$SFline = <SFFASTQ2INPUT>;
		print SFFASTQOUTPUT $SFline; 
		$SFline = <SFFASTQ2INPUT>;
		print SFFASTQOUTPUT $SFline;
		$SFline = <SFFASTQ2INPUT>;
		print SFFASTQOUTPUT $SFline;
		$SFline = <SFFASTQ2INPUT>;
		print SFFASTQOUTPUT $SFline;
	}
	close SFFASTQ1INPUT;
	close SFFASTQ2INPUT;
	close SFFASTQOUTPUT;
	
	return $FastqKit_success;
}



### Compare fastq ids and output shared uniqueR1 and uniqueR2
### FastqCompareIds($inR1.fq[.gz], $inR2.fq[.gz], $pattern, $out_shared.list, $out_uniqueR1.list, $out_uniqueR2.list)
### Pattern Pattern:
#    Pattern1: '\\@(\\S+)\\/[12]\\s*\\S*'
#    Pattern2: '\\@(\\S+)\\s*\\S*'
### Global: 
### Dependency: zcat
### Note
sub FastqCompareIds {
	my ($FCIfq1in, $FCIfq2in, $FCIpattern, $FCIfqShareout, $FCIfqU1out, $FCIfqU2out)=@_;

	my $FCIsubinfo='SUB(FastqKit::FastqCompareIds)';
	my %FCIshared_ids=();
	my $FCInum_share=0;
	my $FCInum_unique1=0;
	my $FCInum_unique2=0;
	$FCIpattern='\@(\S+)\/[12]\s*\S*' unless (defined $FCIpattern);
	local *FCIFASTQ1INPUT; local *FCIFASTQ2INPUT;
	local *FCISHARED; local *FCIUNIQUE1; local *FCIUNIQUE2;

	unless (defined $FCIfq1in and -s $FCIfq1in) {
		print STDERR $FCIsubinfo, "Error: invalid input fastq R1\n";
		return $FastqKit_failure;
	}
	unless (defined $FCIfq2in and -s $FCIfq2in) {
		print STDERR $FCIsubinfo, "Error: invalid input fastq R2\n";
		return $FastqKit_failure;
	}
	unless (defined $FCIfqShareout) {
		print STDERR $FCIsubinfo, "Error: invalid input shared fastq ID list\n";
		return $FastqKit_failure;
	}
	unlink $FCIfqShareout if (-e $FCIfqShareout);
	unless (defined $FCIfqU1out) {
		print STDERR $FCIsubinfo, "Error: invalid input unique R1 fastq ID list\n";
		return $FastqKit_failure;
	}
	unlink $FCIfqU1out if (-e $FCIfqU1out);
	unless (defined $FCIfqU2out) {
		print STDERR $FCIsubinfo, "Error: invalid input unique R2 fastq ID list\n";
		return $FastqKit_failure;
	}
	unlink $FCIfqU2out if (-e $FCIfqU2out);
	
### Summary
	print $FCIsubinfo, "###### Summary input #####\n";
	print "    MateR1:         $FCIfq1in\n";
	print "    MateR2:         $FCIfq2in\n";
	print "    Pattern:        $FCIpattern\n";
	print "    Out shared:     $FCIfqShareout\n";
	print "    Out unique R1:  $FCIfqU1out\n";
	print "    Out unique R2:  $FCIfqU2out\n";
	print "\n";
	
	close FCIFASTQ1INPUT if (defined fileno(FCIFASTQ1INPUT));
	if ($FCIfq1in=~/\.gz$/i) {
		unless (open FCIFASTQ1INPUT, "zcat $FCIfq1in | ") {
			print STDERR $FCIsubinfo, "Error: can not open gzipped fastq R1: $FCIfq1in\n";
			return $FastqKit_failure;
		}
	}
	elsif ($FCIfq1in=~/(\.fq$)|(\.fastq$)/i) {
		unless (open FCIFASTQ1INPUT, " < $FCIfq1in") {
			print STDERR $FCIsubinfo, "Error: can not open fastq R1: $FCIfq1in\n";
			return $FastqKit_failure;
		}
	}
	else {
		print STDERR $FCIsubinfo, "Error: can not guess fastq R1 format: $FCIfq1in\n";
		return $FastqKit_failure;
	}

	while (my $FCIline1=<FCIFASTQ1INPUT>) {
		my $FCIid1='';
		if ($FCIline1=~m/$FCIpattern/) {
			$FCIid1=$1;
			if ($FCIid1 eq '') {
				print STDERR $FCIsubinfo, "Error: invalid R1 ID pattern\n";
				return $FastqKit_failure;
			}
			$FCIshared_ids{$FCIid1}++;
			<FCIFASTQ1INPUT> && <FCIFASTQ1INPUT> && <FCIFASTQ1INPUT>;
		} 
		else {
			print STDERR $FCIsubinfo, "Error: invalid fastq R1 ID: $FCIline1\n";
			return $FastqKit_failure;
		}
	}
	close FCIFASTQ1INPUT;

	if ($FCIfq2in=~/\.gz$/i) {
		unless (open FCIFASTQ2INPUT, "zcat $FCIfq2in | ") {
			print STDERR $FCIsubinfo, "Error: can not open gzipped fastq R2: $FCIfq2in\n";
			return $FastqKit_failure;
		}
	}
	elsif ($FCIfq2in=~/(\.fq$)|(\.fastq$)/i) {
		unless (open FCIFASTQ2INPUT, " < $FCIfq2in") {
			print STDERR $FCIsubinfo, "Error: can not open fastq R2: $FCIfq2in\n";
			return $FastqKit_failure;
		}
	}
	else {
		print STDERR $FCIsubinfo, "Error: can not guess fastq R2 format: $FCIfq2in\n";
		return $FastqKit_failure;
	}
	close FCISHARED if (defined fileno(FCISHARED));
	unless (open FCISHARED, " > $FCIfqShareout") {
		print STDERR $FCIsubinfo, "Error: can not write shared IDs: $FCIfqShareout\n";
		return $FastqKit_failure;
	}
	close FCIUNIQUE2 if (defined fileno(FCIUNIQUE2));
	unless (open FCIUNIQUE2, " > $FCIfqU2out") {
		print STDERR $FCIsubinfo, "Error: can not write unique R2 IDs: $FCIfqU2out\n";
		return $FastqKit_failure;
	}
	while (my $FCIline2=<FCIFASTQ2INPUT>) {
		my $FCIid2='';
		if ($FCIline2=~m/$FCIpattern/) {
			$FCIid2=$1;
			if ($FCIid2 eq '') {
				print STDERR $FCIsubinfo, "Error: invalid R2 ID pattern\n";
				return $FastqKit_failure;
			}
			if (exists $FCIshared_ids{$FCIid2}) {
				print FCISHARED $FCIid2."\n";
				$FCInum_share++;
				delete $FCIshared_ids{$FCIid2};
			}
			else {
				print FCIUNIQUE2 $FCIid2."\n";
				$FCInum_unique2++;
			}
			<FCIFASTQ2INPUT> && <FCIFASTQ2INPUT> && <FCIFASTQ2INPUT>;
		}
		else {
			print STDERR $FCIsubinfo, "Error: invalid fastq R2 ID: $FCIline2\n";
			return $FastqKit_failure;
		}
	}
	close FCIFASTQ2INPUT;
	close FCISHARED;
	close FCIUNIQUE2;
	
	close FCIUNIQUE1 if (defined fileno(FCIUNIQUE1));
	unless (open FCIUNIQUE1, " > $FCIfqU1out") {
		print STDERR $FCIsubinfo, "Error: can not write unique R1 IDs: $FCIfqU1out\n";
		return $FastqKit_failure;
	}
	foreach my $FCIid3 (keys %FCIshared_ids) {
		print FCIUNIQUE1 $FCIid3, "\n";
		$FCInum_unique1++;
	}
	close FCIUNIQUE1;

	print $FCIsubinfo, "###### Summary Output #####\n";
	print "    Shared:    $FCInum_share\n";
	print "    UniqueR1:  $FCInum_unique1\n";
	print "    UniqueR2:  $FCInum_unique2\n";
	
	return $FastqKit_success;
}




### 
### 
### Global:
### Dependency:
### Note: 
### Return: 1=Success    0=failure
#sub XXXXX {
#	my $subinfo='SUB(FastqKit::XXX)';
#	return $FastqKit_failure;
#	return $FastqKit_success;
#}



#my $SFFsubinfo='SUB(FastqKit::ShuffleFastq2Fasta)';
#$FastqKit_success; $FastqKit_failure;
1;
